# %% [markdown]
# ## 📘 M1.3 NumPy 陣列的索引與切片技巧
# 
# 本教學將詳細介紹如何有效地從 NumPy 陣列中選取、修改和操作數據。
# 掌握這些技巧可以大大提高數據處理的效率和靈活性。

# %% [markdown]
# ### 🎯 教學目標
# 
# - 🔍 學習 NumPy 陣列的基本索引方法
# - 📐 掌握多維陣列的切片技巧
# - 🧠 了解高級索引方法 (布林索引、花式索引)
# - 🛠️ 學會如何有效地修改陣列子集

# %%
### 🧰 1. 環境設置與導入必要的套件

# %%
**學習要點**：
- 匯入 NumPy 套件與設定顯示選項
- 理解適當設置的重要性

**應用場域**：
- 資料分析與科學計算的環境準備
- 讓輸出結果更加易讀且具可解釋性

# %%
import numpy as np

# 設定顯示選項，使輸出更易讀
np.set_printoptions(precision=3, suppress=True)

# %%
**解說**：
- `precision=3` 將浮點數顯示限制為3位小數，提高可讀性
- `suppress=True` 抑制科學計數法顯示，避免過大或過小的數以指數形式呈現

# %%
### 🔢 2. 一維陣列的基本索引與切片

# %%
**學習要點**：
- 掌握單一元素索引的語法與意義
- 學習切片操作的參數設置
- 理解正負索引在陣列中的差異

**應用場域**：
- 時間序列資料截取特定區間
- 特徵工程中選取部分特徵
- 資料預處理中的序列轉換

# %%
# 建立一個一維陣列
arr_1d = np.arange(10)
print(f"原始一維陣列: {arr_1d}")

# 單一元素索引 (從 0 開始)
print(f"arr_1d[0]: {arr_1d[0]}")   # 第一個元素
print(f"arr_1d[5]: {arr_1d[5]}")   # 第六個元素
print(f"arr_1d[-1]: {arr_1d[-1]}")  # 最後一個元素
print(f"arr_1d[-2]: {arr_1d[-2]}")  # 倒數第二個元素

# 切片: arr[start:stop:step]
print(f"\n前三個元素 arr_1d[0:3]: {arr_1d[0:3]}")
print(f"索引 1 到 5 (不含 6) arr_1d[1:6]: {arr_1d[1:6]}")
print(f"每隔一個元素 arr_1d[::2]: {arr_1d[::2]}")
print(f"反轉陣列 arr_1d[::-1]: {arr_1d[::-1]}")

# 省略切片參數
print(f"\n從頭到索引 5 (不含) arr_1d[:5]: {arr_1d[:5]}")
print(f"從索引 5 到尾 arr_1d[5:]: {arr_1d[5:]}")
print(f"整個陣列的複製 arr_1d[:]: {arr_1d[:]}")

# %%
**解說**：
- NumPy 陣列索引從 0 開始，負索引代表從尾部向前計數
- 切片格式 `arr[start:stop:step]` 中，最終結果包含 start 但不包含 stop
- 省略參數時有預設值：start=0、stop=陣列長度、step=1
- `arr[::-1]` 是反轉陣列的常用技巧，step 為 -1 表示反向取值

# %%
### 🔳 3. 二維陣列的索引與切片

# %%
**學習要點**：
- 理解二維陣列的座標系統 (列、行)
- 學習獲取特定元素、列、行的方法
- 掌握子矩陣的切片技巧

**應用場域**：
- 影像處理中截取特定區域
- 表格資料的行列選取
- 地理空間數據分析中的區域選擇

# %%
# 建立一個 3x4 的二維陣列
arr_2d = np.arange(12).reshape(3, 4)
print(f"二維陣列 (3x4):\n{arr_2d}")

# 訪問單一元素: arr[row, col]
print(f"\n第一列第一行元素 arr_2d[0, 0]: {arr_2d[0, 0]}")
print(f"第二列第三行元素 arr_2d[1, 2]: {arr_2d[1, 2]}")
print(f"最後一列最後一行元素 arr_2d[-1, -1]: {arr_2d[-1, -1]}")

# 訪問整列或整行
print(f"\n第一列 (row) arr_2d[0]: {arr_2d[0]}")
print(f"第一行 (column) arr_2d[:, 0]: {arr_2d[:, 0]}")
print(f"最後一列 arr_2d[-1]: {arr_2d[-1]}")

# 切片: 子矩陣
print(f"\n前兩列 arr_2d[0:2]:\n{arr_2d[0:2]}")
print(f"前兩列的前三行 arr_2d[0:2, 0:3]:\n{arr_2d[0:2, 0:3]}")
print(f"所有列的偶數行 arr_2d[:, ::2]:\n{arr_2d[:, ::2]}")

# %%
**解說**：
- 二維陣列使用 `arr[row, col]` 語法進行索引，也可用 `arr[row][col]`
- 只提供一個索引 `arr[0]` 時會返回整個列（一個一維陣列）
- 使用 `:` 表示選取該維度的所有元素，如 `arr[:, 0]` 表示所有列的第一行
- 二維切片在各個維度都支持 start:stop:step 格式

# %%
### 🧊 4. 三維及更高維度陣列的索引

# %%
**學習要點**：
- 理解三維及更高維度的索引機制
- 學習在多個維度上進行切片
- 掌握多維數據的訪問層次

**應用場域**：
- 視頻資料處理 (時間+圖像)
- 三維醫學影像分析
- 多維時空數據的科學模擬

# %%
# 建立一個 2x3x4 的三維陣列 (2個 3x4 的矩陣)
arr_3d = np.arange(24).reshape(2, 3, 4)
print(f"三維陣列 (2x3x4):\n{arr_3d}")

# 訪問單一元素: arr[depth, row, col]
print(f"\n特定元素 arr_3d[0, 1, 2]: {arr_3d[0, 1, 2]}")  # 第1個矩陣，第2列，第3行

# 訪問特定的二維矩陣
print(f"\n第一個矩陣 arr_3d[0]:\n{arr_3d[0]}")

# 訪問特定的一維向量 (行或列)
print(f"\n第一個矩陣的第一列 arr_3d[0, 0]:\n{arr_3d[0, 0]}")
print(f"所有矩陣的第一列第一行元素 arr_3d[:, 0, 0]: {arr_3d[:, 0, 0]}")

# 切片: 多維子陣列
print(f"\n第一個矩陣的部分切片 arr_3d[0, :2, :2]:\n{arr_3d[0, :2, :2]}")

# %%
**解說**：
- 三維陣列可視為「矩陣的矩陣」，索引順序為 [depth, row, column]
- 高維數據切片的核心原則與低維相同，每個維度可獨立操作
- 多維切片中的每個維度都支持完整的切片語法
- 部分維度索引後會降低陣列的維度，如 `arr_3d[0]` 返回一個二維陣列

# %%
### ✏️ 5. 修改陣列元素

# %%
**學習要點**：
- 學習如何修改陣列中的單一元素
- 掌握批量修改陣列子集的技巧
- 理解不同索引方法修改元素的影響

**應用場域**：
- 資料清洗中的異常值替換
- 特徵工程中的資料轉換
- 資料增強或模擬環境中的值操作

# %%
# 修改一維陣列的元素
arr_1d_copy = arr_1d.copy()  # 創建副本避免修改原始陣列
print(f"原始一維陣列: {arr_1d_copy}")

# 修改單一元素
arr_1d_copy[0] = 100
print(f"修改後 (arr_1d_copy[0] = 100): {arr_1d_copy}")

# 修改切片 (多個元素)
arr_1d_copy[1:4] = 200
print(f"修改後 (arr_1d_copy[1:4] = 200): {arr_1d_copy}")

# 修改切片為序列 (長度必須匹配)
arr_1d_copy[5:8] = [500, 600, 700]
print(f"修改後 (arr_1d_copy[5:8] = [500, 600, 700]): {arr_1d_copy}")

# 修改二維陣列
arr_2d_copy = arr_2d.copy()
print(f"\n原始二維陣列:\n{arr_2d_copy}")

# 修改單一元素
arr_2d_copy[0, 0] = 99
print(f"\n修改後 (arr_2d_copy[0, 0] = 99):\n{arr_2d_copy}")

# 修改整列
arr_2d_copy[1] = [11, 22, 33, 44]
print(f"\n修改後 (arr_2d_copy[1] = [11, 22, 33, 44]):\n{arr_2d_copy}")

# 修改子矩陣
arr_2d_copy[1:3, 2:4] = [[55, 66], [77, 88]]
print(f"\n修改後 (arr_2d_copy[1:3, 2:4] = [[55, 66], [77, 88]]):\n{arr_2d_copy}")

# %%
**解說**：
- 可以使用任何索引方法來修改陣列元素，賦值操作直接改變原陣列
- 使用切片修改時，可以賦值單一值（會廣播到所有選定元素）或同形狀序列
- 多維修改時，替換值的維度必須與選擇區域相匹配
- 在進行修改前創建副本 `.copy()` 是良好實踐，避免意外修改原數據

# %%
### 🎭 6. 布林索引 (Boolean Indexing)

# %%
**學習要點**：
- 使用條件表達式創建布林遮罩
- 學習如何用布林索引選取符合條件的元素
- 掌握組合條件的布林索引方法

**應用場域**：
- 資料過濾（如選取高於閾值的數據）
- 異常值檢測與處理
- 資料清洗中的條件式選取

# %%
# 布林索引允許基於條件選取元素
arr = np.arange(10)
print(f"原始陣列: {arr}")

# 創建布林遮罩
mask = arr > 5
print(f"布林遮罩 (arr > 5): {mask}")

# 使用布林遮罩選取元素
filtered = arr[mask]
print(f"過濾後的陣列 (arr[mask]): {filtered}")

# 直接使用條件表達式
print(f"直接用條件 (arr[arr > 5]): {arr[arr > 5]}")
print(f"偶數元素 (arr[arr % 2 == 0]): {arr[arr % 2 == 0]}")
print(f"介於 3 和 7 之間的元素 (arr[(arr >= 3) & (arr <= 7)]): {arr[(arr >= 3) & (arr <= 7)]}")

# 修改符合條件的元素
arr_copy = arr.copy()
arr_copy[arr_copy > 5] = 99
print(f"\n修改後 (arr_copy[arr_copy > 5] = 99): {arr_copy}")

# 在二維陣列上使用布林索引
arr_2d = np.arange(12).reshape(3, 4)
print(f"\n二維陣列:\n{arr_2d}")

# 選取值大於 5 的元素 (結果會被展平)
print(f"值大於 5 的元素: {arr_2d[arr_2d > 5]}")

# 選取行的和大於 10 的列
row_sums = arr_2d.sum(axis=1)  # 沿著行計算和
print(f"每一列的和: {row_sums}")
print(f"行的和大於 10 的列:\n{arr_2d[row_sums > 10]}")

# %%
**解說**：
- 布林索引通過條件創建一個與陣列同形狀的布林遮罩（True/False）
- 使用布林遮罩索引時，只返回遮罩中 True 位置的元素
- 組合條件需使用 `&`（且）、`|`（或）、`~`（非）運算符，而非 `and`、`or`、`not`
- 多維陣列布林索引的結果通常會降維並展平，除非條件按行或列應用

# %%
### 🧩 7. 花式索引 (Fancy Indexing)

# %%
**學習要點**：
- 使用整數陣列進行非連續位置的索引
- 熟悉多維花式索引的規則與用法
- 理解花式索引與切片的區別

**應用場域**：
- 隨機抽樣與資料重排
- 特徵選擇中的非連續特徵抽取
- 資料融合時的列對齊

# %%
# 建立一個用於演示的陣列
arr = np.arange(10) * 10  # [0, 10, 20, ..., 90]
print(f"原始陣列: {arr}")

# 使用整數索引陣列進行索引
indices = [1, 3, 5, 8]
print(f"選取的索引: {indices}")
print(f"選取的元素 arr[indices]: {arr[indices]}")

# 使用負索引
negative_indices = [-1, -3, -5]
print(f"\n負索引: {negative_indices}")
print(f"選取的元素 arr[negative_indices]: {arr[negative_indices]}")

# 二維陣列的花式索引
arr_2d = np.arange(16).reshape(4, 4)
print(f"\n二維陣列:\n{arr_2d}")

# 選取特定的列
rows = [0, 2, 3]
print(f"選取的列 arr_2d[rows]:\n{arr_2d[rows]}")

# 選取特定的列和行 (使用兩個索引陣列)
rows = [0, 2, 3]
cols = [1, 2, 0]
print(f"\n選取的列和行 arr_2d[rows, cols]:\n{arr_2d[rows, cols]}")
# 注意：這會選取 (0,1), (2,2), (3,0) 位置的元素

# 選取特定的子矩陣
print(f"\n選取特定子矩陣 arr_2d[rows][:, cols]:\n{arr_2d[rows][:, cols]}")
# 這會選取 rows 指定的列，然後每一列中 cols 指定的行

# %%
**解說**：
- 花式索引使用整數陣列作為索引，可選取非連續位置的元素
- 一維索引時很直觀，返回索引陣列中指定位置的元素
- 多維索引時有兩種行為：
  - `arr_2d[rows, cols]` 選取元素對（對應位置）
  - `arr_2d[rows][:, cols]` 選取子矩陣（先選列再選行）
- 花式索引總是創建陣列的副本，而非視圖

# %%
### 🔄 8. 組合索引方法

# %%
**學習要點**：
- 學習如何組合不同的索引技術
- 理解複合條件選取的順序和效果
- 掌握多步驟索引的鏈式操作

**應用場域**：
- 複雜資料分析中的多條件篩選
- 特徵工程中的高級選取技巧
- 多層次的數據分組與分析

# %%
# 建立一個 5x5 的陣列
arr_2d = np.arange(25).reshape(5, 5)
print(f"5x5 陣列:\n{arr_2d}")

# 組合花式索引和切片
rows = [0, 2, 4]
print(f"\n選擇特定列的前三行 arr_2d[rows, :3]:\n{arr_2d[rows, :3]}")

# 組合花式索引和布林索引
mask = np.array([True, False, True, False, True])  # 選擇第1, 3, 5列
print(f"\n使用布林遮罩選擇列 arr_2d[mask]:\n{arr_2d[mask]}")

# 先使用布林索引過濾，再使用花式索引
filtered = arr_2d[arr_2d[:, 0] > 10]  # 第一行值大於10的列
print(f"\n第一行值大於10的列:\n{filtered}")
print(f"上述結果的特定行 filtered[:, [1, 3]]:\n{filtered[:, [1, 3]]}")

# %%
**解說**：
- 不同索引方法可以組合使用，以實現更複雜的選取
- 布林索引與花式索引組合時，通常先應用布林條件再用花式索引選取
- 多步驟索引時要注意返回結果的形狀和類型，某些操作會改變維度
- 組合索引可能導致原始索引關係變得不直觀，需小心處理

# %%
### 🔄 9. 進階: 索引的視圖與副本

# %%
**學習要點**：
- 區分切片產生的視圖與副本的區別
- 理解不同索引方法返回的結果類型
- 掌握 `.copy()` 方法的正確使用時機

**應用場域**：
- 大型數據集的記憶體優化
- 避免意外修改導致的程式錯誤
- 並行處理中的數據隔離

# %%
# 建立一個陣列
arr = np.arange(10)
print(f"原始陣列: {arr}")

# 切片創建視圖 (view) - 共享同一塊數據
arr_view = arr[3:7]  # 視圖
print(f"\n視圖 arr_view: {arr_view}")

# 修改視圖會影響原始陣列
arr_view[0] = 99
print(f"修改視圖後，原始陣列: {arr}")

# 使用 copy() 創建副本
arr = np.arange(10)  # 重置
arr_copy = arr[3:7].copy()  # 副本
print(f"\n副本 arr_copy: {arr_copy}")

# 修改副本不會影響原始陣列
arr_copy[0] = 99
print(f"修改副本後，原始陣列: {arr}")

# 花式索引總是返回副本
arr = np.arange(10)  # 重置
indices = [2, 4, 6]
arr_fancy = arr[indices]  # 副本
print(f"\n花式索引結果: {arr_fancy}")

# 修改不影響原始陣列
arr_fancy[0] = 99
print(f"修改後，原始陣列: {arr}")

# %%
**解說**：
- 切片索引返回「視圖」(view)，與原陣列共享底層數據，修改會互相影響
- 花式索引和布林索引返回「副本」(copy)，與原陣列分離，修改不會互相影響
- 使用 `.copy()` 方法可以顯式創建副本，避免意外修改原始數據
- 在並行計算或需要保留原始數據的場景中，理解視圖與副本的差異至關重要

# %%
### 📝 10. 實用技巧與注意事項

# %%
**學習要點**：
- 掌握索引與切片的最佳實踐
- 了解常見的陷阱與避免方法
- 學習高級索引的實用技巧

**應用場域**：
- 程式碼優化與效能調校
- 避免常見索引錯誤
- 解決複雜的資料選取問題

# %% [markdown]
# ### 索引實用技巧
# 
# 1. **連續整數索引**：使用切片 `arr[start:stop:step]` 比使用列表 `arr[[0,1,2,3]]` 更高效
# 2. **負索引**：從陣列尾部向前計數，`arr[-1]` 是最後一個元素
# 3. **省略參數**：`arr[:]` 建立整個陣列的視圖，`arr[1:]` 從第二個元素到結尾
# 4. **多維切片**：使用逗號分隔每個維度的切片，如 `arr[0:2, 1:3]`
# 5. **使用 `...`**：代表任意數量的 `:` 切片，如 `arr[0, ..., 2]` 等同於 `arr[0, :, :, 2]`
# 
# ### 常見陷阱與注意事項
# 
# 1. **視圖 vs 副本**：切片產生視圖，修改會影響原陣列；花式索引產生副本，修改不影響原陣列
# 2. **連續切片**：如 `arr[1:5][2:4]` 並不等同於 `arr[3:5]`，而是對第一次切片結果再次切片
# 3. **廣播與索引結合**：修改子陣列時注意形狀匹配，如 `arr[1:3, 1:3] = 99`
# 4. **布林索引**：條件表達式使用 `&`, `|`, `~` 而非 `and`, `or`, `not`，且需要用括號分組
# 5. **空結果**：如果條件不匹配任何元素，返回空陣列而非錯誤 

# %%
**解說**：
- 索引技巧能大幅提高代碼效率和可讀性，如使用 `...` 簡化高維索引
- 理解視圖與副本的區別對避免 NumPy 中的常見錯誤至關重要
- 布林運算中 `&`、`|`、`~` 是對陣列逐元素操作，而 `and`、`or`、`not` 是邏輯運算符
- 多維索引時思考「先列後行」(`arr[row, col]`) 的方式，與數學上的矩陣表示一致 